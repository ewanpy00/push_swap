# Документация функций Push Swap

## Структуры данных

### t_stack
Структура для представления узла стека:
- `size` - размер стека
- `value` - значение элемента
- `index` - индекс элемента (позиция в отсортированном массиве)
- `pos` - относительная позиция в стеке (положительная для верхней половины, отрицательная для нижней)
- `target_pos` - целевая позиция для вставки
- `cost_a` - стоимость перемещения в стеке A
- `cost_b` - стоимость перемещения в стеке B
- `next` - указатель на следующий элемент

### t_chunk
Структура для работы с чанками:
- `chunk_counter` - текущий номер чанка
- `chunk_length` - длина одного чанка
- `chunk_amount` - количество чанков

---

## Операции со стеками (operators/)

### Swap операции (swap_ops.c)

#### `void sa(t_stack **a)`
Меняет местами первые два элемента стека A.
- Выводит "sa\n"
- Если стек пуст или содержит менее 2 элементов, ничего не делает

#### `void sb(t_stack **b)`
Меняет местами первые два элемента стека B.
- Выводит "sb\n"
- Если стек пуст или содержит менее 2 элементов, ничего не делает

#### `void ss(t_stack **a, t_stack **b)`
Одновременно выполняет `sa` и `sb`.
- Выводит "ss\n"
- Если один из стеков пуст или содержит менее 2 элементов, ничего не делает

### Push операции (push_ops.c)

#### `void pa(t_stack **a, t_stack **b)`
Перемещает первый элемент из стека B в начало стека A.
- Выводит "pa\n"
- Если стек B пуст, ничего не делает

#### `void pb(t_stack **a, t_stack **b)`
Перемещает первый элемент из стека A в начало стека B.
- Выводит "pb\n"
- Если стек A пуст, ничего не делает

### Rotate операции (rotate_ops.c)

#### `void ra(t_stack **a)`
Сдвигает все элементы стека A вверх на одну позицию (первый элемент становится последним).
- Выводит "ra\n"
- Если стек пуст или содержит менее 2 элементов, ничего не делает

#### `void rb(t_stack **b)`
Сдвигает все элементы стека B вверх на одну позицию (первый элемент становится последним).
- Выводит "rb\n"
- Если стек пуст или содержит менее 2 элементов, ничего не делает

#### `void rr(t_stack **a, t_stack **b)`
Одновременно выполняет `ra` и `rb`.
- Выводит "rr\n"
- Если один из стеков пуст или содержит менее 2 элементов, ничего не делает

### Reverse rotate операции (reverse_rotate_ops.c)

#### `void rra(t_stack **a)`
Сдвигает все элементы стека A вниз на одну позицию (последний элемент становится первым).
- Выводит "rra\n"
- Если стек пуст или содержит менее 2 элементов, ничего не делает

#### `void rrb(t_stack **b)`
Сдвигает все элементы стека B вниз на одну позицию (последний элемент становится первым).
- Выводит "rrb\n"
- Если стек пуст или содержит менее 2 элементов, ничего не делает

#### `void rrr(t_stack **a, t_stack **b)`
Одновременно выполняет `rra` и `rrb`.
- Выводит "rrr\n"
- Если один из стеков пуст или содержит менее 2 элементов, ничего не делает

#### `void rra_no_write(t_stack **stack_a)`
Выполняет `rra` без вывода команды (используется внутри `rrr`).

#### `void rrb_no_write(t_stack **stack_b)`
Выполняет `rrb` без вывода команды (используется внутри `rrr`).

---

## Утилиты парсинга (utils/)

### Парсинг чисел (atoi_utils.c)

#### `int ft_atoi(const char *str, int *error)`
Преобразует строку в целое число с проверкой переполнения.
- **Параметры:**
  - `str` - строка для преобразования
  - `error` - указатель на флаг ошибки (устанавливается в 1 при ошибке)
- **Возвращает:** преобразованное число или 0 при ошибке
- **Ошибки:** переполнение INT_MAX/INT_MIN, неверный формат, пустая строка после знака

#### `static void init_atoi_state(long *result, int *sign, int *i, int *error)`
Инициализирует переменные для `ft_atoi`.

#### `static void handle_sign(const char *str, int *i, int *sign)`
Обрабатывает знак числа (+ или -).

#### `static int validate_first_digit(const char *str, int i, int *error)`
Проверяет наличие хотя бы одной цифры после знака.

#### `static int process_digits(const char *str, long *result, int sign, int *i)`
Обрабатывает цифры и проверяет переполнение.

### Парсинг аргументов (parse_utils.c)

#### `int has_duplicates(t_stack *a, int value)`
Проверяет наличие дубликата значения в стеке.
- **Параметры:**
  - `a` - стек для проверки
  - `value` - значение для поиска
- **Возвращает:** 1 если дубликат найден, 0 иначе

#### `int parse_arguments(int ac, char **av, t_stack **a)`
Парсит аргументы командной строки и создает стек.
- **Параметры:**
  - `ac` - количество аргументов
  - `av` - массив аргументов
  - `a` - указатель на стек (результат)
- **Возвращает:** 1 при успехе, 0 при ошибке
- **Ошибки:** неверный формат числа, дубликаты, ошибка выделения памяти

#### `static int validate_value(int value, int error, t_stack **a)`
Проверяет валидность значения (ошибка парсинга или дубликат).

#### `static int init_new_node(t_stack **a, int value)`
Создает новый узел стека и добавляет его в начало.

### Парсинг входных данных (parse_helpers.c)

#### `int parse_input(int ac, char **av, t_stack **a)`
Главная функция парсинга входных данных.
- Обрабатывает случай одного аргумента (строка с пробелами) или множественных аргументов
- **Возвращает:** 1 при успехе, 0 при ошибке

#### `static int parse_single_arg(char *arg, t_stack **a)`
Парсит один аргумент, содержащий несколько чисел через пробелы.

#### `static int parse_multiple_args(int ac, char **av, t_stack **a)`
Парсит множественные аргументы командной строки.

### Разделение строк (split_utils.c)

#### `int count_words(char *str)`
Подсчитывает количество слов в строке (разделители: пробел и табуляция).

#### `void free_split(char **arr)`
Освобождает память, выделенную для массива строк.

### Разделение строк - вспомогательные (split_helpers.c)

#### `char **split_arguments(char *str, int *count)`
Разделяет строку на массив слов по пробелам и табуляциям.
- **Параметры:**
  - `str` - строка для разделения
  - `count` - указатель на переменную для количества слов
- **Возвращает:** массив строк или NULL при ошибке

#### `static void free_result_array(char **result, int j)`
Освобождает массив строк при ошибке выделения памяти.

#### `static int alloc_word(char **result, int j, int start, int end, char *str)`
Выделяет память и копирует слово из строки.

#### `static int skip_whitespace(char *str, int *i)`
Пропускает пробелы и табуляции, возвращает 1 если есть непробельный символ.

#### `static int extract_word(char *str, int *i, int *start)`
Извлекает следующее слово из строки.

### Утилиты стека (stack_utils.c)

#### `void free_stack(t_stack **stack)`
Освобождает всю память, выделенную для стека.

#### `int is_sorted(t_stack *a)`
Проверяет, отсортирован ли стек по возрастанию.
- **Возвращает:** 1 если отсортирован, 0 иначе

#### `void reverse_stack(t_stack **a)`
Разворачивает стек (меняет порядок элементов на противоположный).

---

## Алгоритмы сортировки (algorighm/)

### Работа с чанками (chunk_utils.c)

#### `int stack_size(t_stack *a)`
Подсчитывает количество элементов в стеке.

#### `int in_chunk(t_stack *node, t_chunk *chunk)`
Проверяет, принадлежит ли узел текущему чанку.
- **Параметры:**
  - `node` - узел для проверки
  - `chunk` - структура чанка
- **Возвращает:** 1 если узел в чанке, 0 иначе

#### `int chunk_in_stack(t_stack *a, t_chunk *chunk)`
Проверяет, есть ли элементы текущего чанка в стеке.
- **Возвращает:** 1 если есть, 0 иначе

#### `t_stack *find_closest_in_chunk(t_stack *a, t_chunk *chunk)`
Находит ближайший элемент текущего чанка в стеке и устанавливает его позицию.
- **Возвращает:** указатель на найденный узел или NULL

### Основной алгоритм (algorithm.c)

#### `void set_indexes(t_stack **stack_a)`
Устанавливает индексы для всех элементов стека.
- Индекс = количество элементов с меньшим значением
- Используется для определения позиции элемента в отсортированном массиве

#### `void setup(t_stack **a, int total_size, t_chunk *chunk)`
Настраивает параметры чанков в зависимости от размера стека.
- Размер <= 20: 2 чанка
- Размер <= 100: 5 чанков
- Размер <= 500: 10 чанков
- Размер > 500: 20 чанков
- Также вызывает `set_indexes` для установки индексов

### Вспомогательные функции алгоритма (algorithm_helpers.c)

#### `void push_to_b(t_stack **a, t_stack **b, t_chunk *chunk)`
Основная функция перемещения элементов из стека A в стек B по чанкам.
- Обрабатывает все чанки последовательно
- Для каждого чанка вызывает `process_chunk`

#### `static void rotate_to_target(t_stack **a, t_stack *target)`
Вращает стек A до тех пор, пока целевой элемент не окажется наверху.

#### `static int should_rotate_b(t_stack *b, t_chunk *chunk, int moved)`
Определяет, нужно ли вращать стек B после добавления элемента.
- Вращает, если элемент меньше середины чанка и перемещено менее половины элементов чанка

#### `static void process_chunk(t_stack **a, t_stack **b, t_chunk *chunk)`
Обрабатывает один чанк: находит и перемещает все элементы чанка из A в B.

### Работа с позициями (position_utils.c)

#### `void set_positions(t_stack *stack)`
Устанавливает относительные позиции для всех элементов стека.
- Позиция положительная для верхней половины, отрицательная для нижней

#### `int get_min_index_pos(t_stack *a)`
Находит позицию элемента с минимальным индексом в стеке.

#### `void set_target_pos(t_stack *a, t_stack *b)`
Устанавливает целевую позицию для каждого элемента стека B в стеке A.
- Для каждого элемента B ищет ближайший больший элемент в A
- Если такого нет, использует позицию минимального элемента

#### `static int find_best_position(t_stack *a, int b_index, int *best_pos)`
Находит лучшую позицию для вставки элемента с индексом `b_index` в стек A.

#### `static void set_target_for_node(t_stack *a, t_stack *b_node, int size_a)`
Устанавливает целевую позицию для одного узла стека B.

### Расчет стоимости (cost_utils.c)

#### `void set_costs(t_stack *b)`
Устанавливает стоимость перемещения для каждого элемента стека B.
- `cost_b` - стоимость перемещения элемента в B (положительная для верхней половины, отрицательная для нижней)
- `cost_a` - стоимость перемещения в целевую позицию в A

#### `int calculate_total_cost(int cost_a, int cost_b)`
Вычисляет общую стоимость перемещения элемента.
- Если оба движения в одном направлении, берется максимум
- Если в разных направлениях, складываются абсолютные значения

#### `t_stack *get_cheapest(t_stack *b)`
Находит элемент стека B с минимальной общей стоимостью перемещения.

### Выполнение перемещений (to_stack_a_helpers.c)

#### `void execute_move(t_stack **a, t_stack **b, t_stack *cheapest)`
Выполняет оптимальную последовательность операций для перемещения элемента.
- Сначала выполняет одновременные вращения (rr или rrr)
- Затем оставшиеся вращения для каждого стека отдельно

#### `static void execute_simultaneous_rotations(t_stack **a, t_stack **b, int *cost_a, int *cost_b)`
Выполняет одновременные вращения (rr или rrr) пока возможно.

#### `static void execute_remaining_rotations_a(t_stack **a, int *cost_a)`
Выполняет оставшиеся вращения для стека A (ra или rra).

#### `static void execute_remaining_rotations_b(t_stack **b, int *cost_b)`
Выполняет оставшиеся вращения для стека B (rb или rrb).

### Возврат в стек A (to_stack_a.c)

#### `void push_to_a(t_stack **a, t_stack **b)`
Основная функция перемещения элементов из стека B обратно в стек A.
- Для каждого элемента B:
  - Устанавливает позиции
  - Находит целевую позицию
  - Рассчитывает стоимость
  - Находит самый дешевый элемент
  - Выполняет перемещение
- В конце вызывает `final_rotate` для финальной сортировки

#### `void final_rotate(t_stack **a)`
Выполняет финальное вращение стека A, чтобы минимальный элемент оказался наверху.

---

## Главные функции

### push_swap.c

#### `int main(int ac, char **av)`
Главная функция программы push_swap.
- Парсит аргументы
- Обрабатывает стек (сортирует)
- Освобождает память

#### `static int handle_small_stack(t_stack **a, int size)`
Обрабатывает маленькие стеки (2-3 элемента) специальными алгоритмами.
- **Возвращает:** 1 если стек обработан, 0 если нужен полный алгоритм

#### `static void execute_sorting_algorithm(t_stack **a, t_stack **b, int size)`
Запускает полный алгоритм сортировки для больших стеков.

#### `static int process_stack(t_stack **a, t_stack **b)`
Обрабатывает стек: проверяет сортировку, обрабатывает маленькие стеки или запускает полный алгоритм.

### checker/checker.c

#### `int main(int ac, char **av)`
Главная функция программы checker.
- Парсит аргументы
- Выполняет сортировку (как push_swap)
- Проверяет результат и выводит OK/KO

#### `static void check_result(t_stack **a, t_stack **b)`
Проверяет результат сортировки.
- Выводит "OK\n" если стек A отсортирован и стек B пуст
- Выводит "KO\n" в противном случае

---

## Примечания

- Все функции операций (sa, sb, pa, pb, ra, rb, rra, rrb, ss, rr, rrr) выводят соответствующую команду в stdout
- Функции с префиксом `static` доступны только в файле, где они определены
- Все функции работают с указателями на указатели стеков для возможности изменения головы стека
- Позиции элементов могут быть положительными (верхняя половина) или отрицательными (нижняя половина) для оптимизации вращений

